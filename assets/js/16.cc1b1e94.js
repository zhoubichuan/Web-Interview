(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{184:function(e,_,v){"use strict";v.r(_);var a=v(0),t=Object(a.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"七、浏览器缓存策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、浏览器缓存策略"}},[e._v("#")]),e._v(" 七、浏览器缓存策略")]),e._v(" "),v("h2",{attrs:{id:"_1-浏览器缓存位置和优先级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器缓存位置和优先级"}},[e._v("#")]),e._v(" 1.浏览器缓存位置和优先级")]),e._v(" "),v("ul",[v("li",[e._v("Service Worker")]),e._v(" "),v("li",[e._v("Memory Cache(内存缓存)")]),e._v(" "),v("li",[e._v("Disk Cache(硬盘缓存)")]),e._v(" "),v("li",[e._v("Push Cache(推送缓存)")]),e._v(" "),v("li",[e._v("以上缓存都没有命中就会进行网络请求")])]),e._v(" "),v("h2",{attrs:{id:"_2-不同缓存间的差别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-不同缓存间的差别"}},[e._v("#")]),e._v(" 2.不同缓存间的差别")]),e._v(" "),v("blockquote",[v("p",[e._v("Service Worker")])]),e._v(" "),v("p",[e._v("和 Web Worker 类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Wroker 使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的")]),e._v(" "),v("blockquote",[v("p",[e._v("Memroy Cache")])]),e._v(" "),v("p",[e._v("即内存缓存，内存缓存不是持续性的，缓存会随着进程释放而释放")]),e._v(" "),v("blockquote",[v("p",[e._v("Disk Cache")])]),e._v(" "),v("p",[e._v("即硬盘缓存，相较于内存缓存，硬盘缓存的持续性和容量更优，它会根据 HTTP header 的字段判断哪些资源需要缓存")]),e._v(" "),v("blockquote",[v("p",[e._v("Push Cache")])]),e._v(" "),v("p",[e._v("即推送缓存，是 HTTP/2 的内容，目前应用较少")]),e._v(" "),v("h2",{attrs:{id:"_3-介绍一下浏览器缓存策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-介绍一下浏览器缓存策略"}},[e._v("#")]),e._v(" 3.介绍一下浏览器缓存策略")]),e._v(" "),v("blockquote",[v("p",[e._v("强缓存（不向服务器询问的缓存）")])]),e._v(" "),v("ul",[v("li",[v("p",[e._v("设置 Expires")]),e._v(" "),v("ul",[v("li",[e._v("即过期时间，例如"),v("code",[e._v("Expires:Thu,26 Dec 2019 10:30:42 GMT")]),e._v("表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。")])])]),e._v(" "),v("li",[v("p",[e._v("设置 Cache-Control")]),e._v(" "),v("ul",[v("li",[e._v("HTTP/1.1 新增字段，Cache-Control 可以通过"),v("code",[e._v("max-age")]),e._v("字段来设置过期时间，例如"),v("code",[e._v("Cache-Control:max-age=3600")]),e._v("除此之外 Cache-Control 还能设置"),v("code",[e._v("private/no-cache")]),e._v("等多种字段")])])])]),e._v(" "),v("blockquote",[v("p",[e._v("协商缓存（需要向服务器询问缓存释放已经过期）")])]),e._v(" "),v("ul",[v("li",[v("p",[e._v("Last-Modified")]),e._v(" "),v("ul",[v("li",[e._v("即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上"),v("code",[e._v("Last-Modified")]),e._v(",当浏览器再次请求该资源时，浏览器会在请求头中带上"),v("code",[e._v("If-Modified-Since")]),e._v("字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回 304，否则返回新资源，并更新"),v("code",[e._v("Last-Modified")])])])]),e._v(" "),v("li",[v("p",[e._v("ETag")]),e._v(" "),v("ul",[v("li",[e._v("HTTP/1.1 新增字段，表示文件唯一标识，只要文件内容改动，ETag 就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段--\x3e浏览器再次请求时发送 If-None-Match--\x3e如果 ETag 值不匹配，说明文件已经改变，返回新资源并更新 ETag，若匹配则返回 304")])])])]),e._v(" "),v("blockquote",[v("p",[e._v("两者对比")])]),e._v(" "),v("ul",[v("li",[e._v("ETag 比 Last-Modified 更准确：如果我们打开文件但并没有修改，Last-Modified 也会改变，并且 Last-Modified 的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存")]),e._v(" "),v("li",[e._v("如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值得 10%作为缓存时间")])])])}],!1,null,null,null);_.default=t.exports}}]);